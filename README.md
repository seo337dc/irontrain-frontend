# irontrain-frontend

아이언트레인 프론트엔드 과제

# 실행 방법

- npm install
- npm run build
- npm start

# 문제 해결 방식

## 1. 컴포넌트 분리

- **이유**:

  - 요구사항과 내용을 분석했을 때, 복잡한 UI와 비즈니스 로직이 섞일 가능성이 있어 가독성을 위해 컴포넌트 분리
  - 재사용 가능한 컴포넌트를 설계하여 중복 코드를 제거하고 확장성을 강화.

- **분리된 주요 컴포넌트**:
  1.  `HeaderFilter`:
      - 검색, 필터링, 정렬 등의 기능을 제공하는 UI 섹션.
      - 상태 관리 라이브러리(zustand)를 활용하여 필터 상태를 전역에서 관리.
  2.  `Table`:
      - 테이블 렌더링 전담 컴포넌트.
      - 정렬, 선택, 확장 행 등 다양한 기능 지원.
  3.  `LoadingTemplate`:
      - 데이터를 불러오는 동안 화면에 로딩 상태를 표시하는 컴포넌트.
      - 테이블 외에도 다양한 UI에 적용 가능하도록 설계.
  4.  `ToolTip`:
      - 텍스트가 잘린 경우(overflow: hidden; text-overflow: ellipsis;)에 툴팁을 표시.
      - 마우스오버 시 전체 내용을 툴팁으로 보여주는 기능 포함.
  5.  `CheckBox`:
      - 테이블의 행 선택 기능을 담당하는 컴포넌트.
      - 헤더의 "전체 선택" 체크박스와 행별 체크박스를 개별 컴포넌트로 분리하여 관리.
  6.  `Input`:
      - 데이터 검색 필터.
  7.  `DatePicker`:
      - 날짜 기반 검색 필터.
      - api와 연동하여 데이터를 필터링함
  8.  `RadioGroup`:
      - 성별을 구분하는 라디오 박스.
  9.  `아이콘 Sort, Caret`:
      - 테이블에 노출되는 아이콘

## 2. 테이블 이름 정렬

- **문제**:

  - API 응답 데이터에서 이름이 firstname과 lastname으로 분리되어 있어, 정렬 로직 적용이 어려움.

- **해결 방법**:
  - 응답 데이터를 변환하여 name 필드를 추가
    - firstname과 lastname을 합친 name 필드 생성.
    - 상태(state)에 name 필드를 포함하여 정렬 로직에서 사용.

## 3. 데이터 필터링

- **문제1**:

  - 검색어를 입력하여 테이블 데이터를 필터링할 때, 객체의 모든 필드를 비교해야 하는 경우가 있었음.

- **해결 방법**:

  - Object.values를 사용해 person 객체의 모든 필드 값을 배열반환 하고, some 메서드를 통해 검색어와 일치하는 값이 있는지 확인하여 필터링 방식을 채택
  - 성별, 날짜는 검색어에서 제외

- **문제2**:

  - 검색 필터 외부 분리로 인한 문제.

- **해결 방법**:

  - 검색 필터 영역을 외부로 빼서 테이블 영역과 검색 영역(HeaderSection)을 분리.
  - zustand 상태 관리 라이브러리를 활용하여 검색 상태를 전역적으로 관리.

- **문제3**:

  - 성별 및 날짜를 기반으로 필터링하려 할 때, 각 필터가 테이블 데이터와 독립적으로 작동해야 했으며, 검색 기능과 조화를 이루기 어려움.

- **해결 방법1 (성별 필터)**:

  - RadioGroup 컴포넌트 모듈화:
    - 라디오 버튼을 활용한 성별 선택 UI를 컴포넌트화하여 재사용 가능하도록 설계
  - 성별 필터 라이플사이클 기반으로 API와 연동
    - 사용자가 라디오 버튼을 통해 성별을 선택하면, 선택된 값을 API 요청에 포함.
    - zustand 상태 관리 라이브러리를 활용하여 성별 상태를 전역으로 관리.

- **해결 방법2 (날짜 필터)**:
  - react-date-picker 라이브러리를 활용하여 컴포넌트 모듈화 적용
    - 날짜 필터 라이플사이클 기반으로 API와 연동
  - zustand 상태 관리 라이브러리를 활용하여 날짜 필터 상태를 전역으로 관리.
  - 날짜 필터 싱태를 API와 연동

## 5. 무한 스크롤 구현

- **문제**:

  - 초기 데이터 로드 후 추가 데이터를 가져오는 과정에서, 스크롤 이벤트가 중복 실행되거나 불필요한 API 호출이 발생하는 문제가 생김.
  - 특정 조건에서 무한 스크롤이 정상적으로 작동하지 않거나, `IntersectionObserver`가 예상치 못한 동작을 확인.

- **해결 방법**:
  1. **IntersectionObserver 활용**:
     - 관찰 대상(`observerRef`)과 스크롤 컨테이너(`sectionRef`)를 명확히 설정하여, 스크롤 위치에 따라 추가 데이터를 로드하도록 구현했습니다.
     - `root`, `rootMargin`, `threshold`를 적절히 조정하여 스크롤 동작에 따라 자연스럽게 데이터를 불러옵니다.
  2. **의존성 관리 및 중복 호출 방지**:
     - `useCallback`을 활용해 `fetchData` 함수를 메모이제이션하여, 의존성 변경에 따라 함수를 재생성하지 않도록 했습니다.
     - `isLoading`과 `hasMore` 상태를 활용하여 중복 호출을 방지했습니다.
  3. **스크롤 컨테이너 높이 설정**:
     - 무한 스크롤의 기준 컨테이너(`sectionRef`)에 명확한 높이와 스크롤 속성을 설정했습니다.

4. **상태 초기화 및 데이터 관리**:
   - 필터 조건 변경 시 데이터를 초기화(`setPersons([])`)하고, 새로 로드된 데이터를 `setPersons`로 관리했습니다.
   - `filteredPersons`를 `useMemo`로 최적화하여, 상태 변경 시 불필요한 연산을 방지했습니다.

## 6. 툴팁 구현

- **문제**:

  - 테이블 셀의 내용이 셀의 너비를 초과할 경우, 내용이 잘려서 표시되는 상황 발생.
  - 잘린 내용(ellipsis 처리된 텍스트)을 확인할 수 있도록 툴팁을 제공해야 했음.
  - 툴팁은 내용이 잘리지 않은 경우에는 표시되지 않아야 함.

- **해결 방법**:
  1. **텍스트 잘림 여부 확인:**:
     - scrollWidth > clientWidth를 비교하여 텍스트가 잘렸는지 여부를 확인
     - 잘린 경우에만 툴팁을 활성화.
  2. **툴팁 표시 조건**:
     - 잘린 텍스트(isTruncated: true)에만 툴팁을 표시.
     - onMouseEnter와 onMouseLeave 이벤트로 툴팁 표시 상태를 관리.
